h1. grrid

h2. A Javascript grid control using Prototype.js.

Grrid is a pure javascript spreadsheet-like grid. You can edit the cells' contents inline (as opposed to pop-ups like in many other grid implementations).  It uses Google-maps style scrolling, so that the browser only needs to load the visible contents.  Edits are periodically synchronized with the server.

This project is still just in its infancy, and there are a few features missing, so I wouldn't recommend using it in production just yet. If you want to contribute, or have any comments, please message me.

h3. Features

* Google-maps style scrolling (i.e. lazy loading of grid contents).
* Periodic synchronization of data with server.
* Hold down shift and drag to select an area of cells.
* Click on one of the column headers to select a column.

h3. Licence

Grrid is provided under the "MIT licence":http://www.opensource.org/licenses/mit-license.php.

h3. Dependencies

* "Prototype.js":http://prototypejs.org (version 1.6+)

h3. Targeted Browsers

* Firefox 2+
* IE 7
* Safari 3+

h3. TODOs

* Column resizing
* Different cursor style when selecting
* Intelligent resizing of row number div
* Keep user informed of current status/activity
* Tabbing between cells should cause the grid to scroll (and load new cells)
* Select an entire row
* Add the ability to paste from a spreadsheet
* Parameterize/make configurable the names of the inner and outer divs and the synch frequency
* Allow access to the selected cells (maybe as a typed collection?)


h3. Concept

The concept behind grrid is very simple.  For the moment, at least, you need a few divs on your page, specifically called innerDiv and outerDiv, and also a couple of other divs to hold the row/col indicators. Like this:

<pre><code><div id="columnIndicators"></div>
<div id="rowIndicators"></div>
<outerDiv>
  <innerDiv>
  </innerDiv>
</outerDiv></pre></code>

The innerDiv will be sized so that the whole of your data grid will fit in it. For example, if you have 300 rows and 10 columns, and the cells are 100px wide and 20px high, innerDiv will be 1000x6000 pixels. 

The outerDiv is effectively a viewport through which the user can see a portion of the innerDiv.

As the user scrolls around, cells are removed or added to the innerDiv, so that the visible part of the innerDiv is populated with cells and data.

You need to instantiate a grrid.Grid object with a set of urls.  These urls tell the grrid where it will get it's data (among other things).

The grid can operate in 2 modes: view mode, and edit mode.  In view mode, the contents are not editable.  In edit mode the cells are editable, and the grid will make periodic calls to the server to keep it informed regarding any edits that have been made.  When the user wants to save, the you should call the saveUrl on the server to persist the changes.

Due to the way Prototype javascript 'classes' work, you can easily extend the various classes in grrid.js to have more properties and methods (for example, you can add other properties to the grrid.Cell class if you want a cell to be able to hold more information than just a value).

h3. How to use


h4. grrid.Grid constructor

Make a new grid by calling the constructor for grrid.Grid. This takes 5 arguments, all of which are urls. 

* the synchronization url - this is the url to call on your server which will receive data from the grid to syncrhonize the server's copy of the data.
* cell data url - this is the url to call on your server, which will provide the data for the current area of visible cells.
* save url   - the url to call to permanently persist the current state of the data grid.
* inner div size url - the url to call which will set the size of the inner div.
* show url - the url which shows the grid (in view mode).

e.g. to initialize a grid when the DOM loads:
<pre><code>Event.observe(document, 'dom:loaded', function(){
	grrid.myGrid = null;
    grrid.myGrid = new grrid.Grid(
      '/grrid/update_changed_cells/', //synchronization url
      '/grrid/get_cells/', // cell data url
      '/grrid/save/', // save url
      '/grrid/set_inner_div_size', // inner div size url
      '/grrid/show/' // show url.
    );
	grrid.myGrid.editMode = true; // this sets up the grid in edit mode. Omit if you want view-mode.
});</code></pre>

On the server, you need to write code to accept calls to these urls (see the *Server Urls* section below)

h4. grrid.Grid.insertCell (instance method)

This inserts a new cell into the grid.  Intended to be called by the server (e.g. via RJS if you're using rails).

Parameters:

* x : the x-coordinate of the cell
* y : the y-coordinate of the cell
* cellValue : the string of the cell's contents

h4. grrid.Grid.removeCell (instance method)

This removes a cell from the grid. Intended to be called by the server (e.g. via RJS if you're using rails).

Parameters:

* x : the x-coordinate of the cell
* y : the y-coordinate of the cell

h4. grrid.Grid.saveData (instance method)

This sends the current state of the grid to the server (via the save url specified when the grid was constructed).  You might have a button or a link which could call this method.

No parameters.

h4. grrid.Grid.editMode (property)

This is a boolean property to indicate whether the grid is in edit mode or not. Defaults to false.

h4. grrid.Grid.viewportWidth (property)

Get or set the viewport width as an integer number of pixels. Defaults to 800.

h4. grrid.Grid.viewportHeight (property)

Get or set the viewport height as an integer number of pixels.  Defaults to 300.

h4. grrid.Grid.highlightColor (property)

Get or set the colour to use for highlighting selected cells and columns, as a string with a CSS colour name. Defaults to "lemonChiffon".

h4. grrid.cellHeight (property)

Get or set the height of a cell as an integer number of pixels. Defaults to 18.

h4. grrid.cellWidth (property)

Get or set the width of a cell as an integer number of pixels. Defaults to 100.

h3. Server Urls

This section details what should happen on the server when each of the 5 urls are called. The rails examples I've provided are not meant to be production-quality, but are instead just to give you an impression of how the server code might look.

h4. innerDivSizeUrl

This is called during initialization of the grid and should expect 2 integer parameters: 
* cell_width (in pixels)
* cell_height (in pixels) 

Check your data store to see how many rows and columns the grid should have, and call some javascript which sets the style of the 'innerDiv' DOM element e.g. if you're using rails:

<pre><code>def set_inner_div_size
  height = @data_set.number_of_rows * params[:cell_height].to_i
  width = @data_set.number_of_columns * params[:cell_width].to_i

  render :update do |page|
    page<<"$('innerDiv').setStyle({width: '#{width}px', height: '#{height}px'});"
  end
end</pre></code>

h4. cellDataUrl

This is called whenever the grid needs some new data (as the user scrolls around, or when the grid first loads). 

This should take the following parameters:
* old_x: previous x-coord of the top-left cell in the viewport (won't be sent first time)
* old_y: previous y-coord of the top-left cell in the viewport (won't be sent first time)
* new_x: new x-coord of the top-left cell in the viewport
* new_y: new y-coord of the top-left cell in the viewport
* number_of_cells_x: how many cells across to show
* number_of_cells_y: how many cells down to show

The method should work out which cells you want to add/remove from the viewport, and then repeatedly make calls to removeCell() and insertCell() on your instance of grrid.Grid.  This url is called in exactly the same way in edit mode and view mode.  So your code needs to make sure it's fetching the right data.  For example, in rails:

<pre><code>def get_cells

  # populate additional_cells variable with a collection of grid cells based on the old and new coordinates 
  # and the size of the viewport.

  # FILL IN YOUR CODE HERE, TAKING INTO ACCOUNT WHETHER WE'RE IN EDIT MODE.
  # (i.e. if we're in edit mode, we should include the recent changes, if not, just used last saved version.)
    
  if (params[:old_x])
    # if an old location is provided, populate cells_to_remove variable with a collection of cells to remove from 
    # the grid, based on the old and new coordinates and the size of the viewport.

    # FILL IN YOUR CODE HERE, TAKING INTO ACCOUNT WHETHER WE'RE IN EDIT MODE.
  end

  render :update do |page|
    # add new cells
    additional_cells.each do |cell|
      
      page.call 'grrid.dataSetGrid.insertCell',
          cell.column_position,
          cell.row_position,
          cell.cell_value
    end

    # remove the old cells
    if cells_to_remove
      cells_to_remove.each do |cell|
        page.call 'grrid.dataSetGrid.removeCell', cell.column_position, cell.row_position
      end
    end
  end
end</code></pre>

h4. synchronizationUrl

This is called periodically by the client, to inform the server of changes to cell contents during edit mode.

The client will send a bunch of parameters in a hash, with the cell coordinates as the key (e.g. "1,4") and the cells' new contents as the values.  You should write code to keep track of this changed data which is waiting to be saved (but may be discarded if the user chooses not to save). For example, in rails:

<pre><code>def update_changed_cells
  coords_regex = Regexp.new("^[0-9]+,[0-9]+$")
  
  # loop through all the params which are of the form x,y where x and y are numbers
  params.keys.each do |param_key|
    if coords_regex.match(param_key)
	  # DO SOMETHING HERE TO UPDATE THE SERVER'S COPY OF THE CELLS.
    end
  end

  render :nothing=>true
end</code></pre>

h4. saveUrl

No parameters

When the client calls this url, it is telling the server that it wants to save the current representation of the grid.  Do whatever you need to do to make permanent the server's current representation of the data (which has been kept up to date by all the previous synchronizations). Rails e.g.:

<pre><code>def save
  # DO SOMETHING TO PERMANENTLY SAVE THE SERVER'S COPY OF THE CELLS
  render :nothing=>true
end</code></pre>

h4. showUrl

This is simply the url that you want to redirect to once the data has been saved (i.e. to show the grid in view mode).
You can also implement an edit action if you like, or just use the same action for show and edit and use instance variables to control the state of the grid. e.g.

<pre><code>def show
  # JUST POPULATE YOUR INSTANCE VARIABLES, 
  # WHICH MIGHT INCLUDE ONE TO INDICATE WHETHER WE'RE IN EDIT MODE.
end</code></pre>

h3. Styling

Just use CSS to style the grid how you want.  Below is some example CSS.  It's not beautiful, but it'll get you started.

<pre><code><style type="text/css">
  #outerDiv {
    width: 815px; /* add on 15 for the scrollbars - visible area 800*/
    height: 315px; /* add on 15 for the scrollbars - visible area 400*/
    border: 1px solid black;
    position: relative;
    overflow: scroll; /* set this to hidden if don't want scrollbars */
    float:left;
  }
  #innerDiv {
    position: relative;
    left: 0px;
    top: 0px;
  }
  #columnIndicators {
    border: 1px solid gray;
    height: 20px;
    width: 815px;
    margin-left:22px;
    position: relative;
    overflow: hidden;
  }
  #rowIndicators {
    border: 1px solid gray;
    height: 315px;
    width: 20px;
    float:left;
    position: relative;
    overflow: hidden;
  }
  input.grid-cell-input {
    font-size: 10px;
    border: none;
    font-family:verdana;
    padding:0;
    background-color: white;
  }
  div.grid-cell {
    position:absolute;
    border-top: 1px solid gray;
    border-left: 1px solid gray;
  }
</style></code></pre>




