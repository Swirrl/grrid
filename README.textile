h1. grrid

h2. A Javascript grid control using Prototype.js.

Grrid is a pure javascript spreadsheet-like grid. You can edit the cells' contents inline (as opposed to pop-ups like in many other grid implementations).  It uses Google-maps style scrolling, so that the browser only needs to load the visible contents.  Edits are periodically synchronized with the server.

This project is still just in its infancy, and there are a few features missing, so I wouldn't recommend using it in production just yet. If you want to contribute, or have any comments, please message me.

h3. Features

* Google-maps style scrolling (i.e. lazy loading of grid contents).
* Periodic synchronization of data with server.
* Hold down shift and move the mouse to select an area of cells.
* Click on one of the column headers to select a column.

h3. Licence

Grrid is provided under the "MIT licence":http://www.opensource.org/licenses/mit-license.php.

h3. Dependencies

* "Prototype.js":http://prototypejs.org (version 1.6+)

h3. Targeted Browsers

* Firefox 2+
* IE 7
* Safari 3+

h3. TODOs

* Column resizing
* Different cursor style when selecting
* Intelligent resizing of row number div
* Keep user informed of current status/activity
* Tabbing between cells should cause the grid to scroll (and load new cells)
* Select an entire row
* Add the ability to paste from a spreadsheet
* Parameterize/make configurable the names of the inner and outer divs and the synch frequency
* Allow access to the selected cells (maybe as a typed collection?)


h3. Concept

The concept behind grrid is very simple.  For the moment, at least, you need two divs on your page, specifically called innerDiv and outerDiv. Like this:

<pre><code>
<outerDiv>
  <innerDiv>
  </innerDiv>
</outerDiv>
</pre></code>

The innerDiv will be sized so that the whole of your data grid will fit in it. For example, if you have 300 rows and 10 columns, and the cells are 100px wide and 20px high, innerDiv will be 1000x6000 pixels. 

The outerDiv is effectively a viewport through which the user can see a portion of the innerDiv.

As the user scrolls around, cells are removed or added to the innerDiv, so that the visible part of the innerDiv is populated with cells and data.

All you need to do is construct a grrid.Grid object with a set of urls.  These urls tell the grrid where it will get it's data (among other things).

The grid can operate in 2 modes: view mode, and edit mode.  In view mode, the contents are not editable.  In edit mode the cells are editable, and the grid will make periodic calls to the server to keep the it informed regarding edits have been made.  When the user wants to save, the you should call the saveUrl on the server to persist the changes.

h3. How to use

h4. grrid.Grid constructor

Make a new grid by calling the constructor for grrid.Grid. This takes 5 arguments, all of which are urls. 

* the synchronization url - this is the url to call on your server which will receive data from the grid to syncrhonize the server's copy of the data.
* cell data url - this is the url to call on your server, which will provide the data for the current area of visible cells.
* save url   - the url to call to permanently persist the current state of the data grid.
* inner div size url - the url to call which will set the size of the inner div.
* show url - the url which shows the grid (in view mode).

e.g. to initialize a grid when the DOM loads:
<pre><code>  
  Event.observe(document, 'dom:loaded', function(){
	grrid.myGrid = null;
    grrid.myGrid = new grrid.Grid(
      '/grrid/update_changed_cells/', //synchronization url
      '/grrid/get_cells/', // cell data url
      '/grrid/save/', // save url
      '/grrid/set_inner_div_size', // inner div size url
      '/grrid/show/' // show url.
    );
	grrid.myGrid.editMode = true; // this sets up the grid in edit mode. Omit if you want view-mode.
</code></pre>

On the server, you need to write code to accept calls to these urls (see the *Server Urls* section below)

h4. grrid.Grid.insertCell (instance method)

This inserts a new cell into the grid.  Intended to be called by the server (e.g. via RJS if you're using rails).

Parameters:

* x : the x-coordinate of the cell
* y : the y-coordinate of the cell
* cellValue : the string of the cell's contents

h4. grrid.Grid.removeCell (instance method)

This removes a cell from the grid. Intended to be called by the server (e.g. via RJS if you're using rails).

Parameters:

* x : the x-coordinate of the cell
* y : the y-coordinate of the cell

h4. grrid.Grid.saveData (instance method)

This sends the current state of the grid to the server (via the save url specified when the grid was constructed).  You might have a button or a link which could call this method.

No parameters.

h4. grrid.Grid.editMode (property)

This is a boolean property to indicate whether the grid is in edit mode or not. Defaults to false.

h4. grrid.Grid.viewportWidth (property)

Get or set the viewport width as an integer number of pixels. Defaults to 800.

h4. grrid.Grid.viewportHeight (property)

Get or set the viewport height as an integer number of pixels.  Defaults to 300.

h4. grrid.Grid.hightlightColor (property)

Get or set the colour to use for highlighting selected cells and columns, as a string with a CSS colour name. Defaults to "lemonChiffon".

h4. grrid.cellHeight (property)

Get or set the height of a cell as an integer number of pixels. Defaults to 18.

h4. grrid.cellWidth (property)

Get or set the width of a cell as an integer number of pixels. Defaults to 100.

h3. Server Urls

h4. innerDivSizeUrl

This is called during initialization of the grid and should expect 2 integer parameters: 
* cell_width (in pixels)
* cell_height (in pixels) 

Check your data store to see how many rows and columns the grid should have, and call some javascript which sets the style of the 'innerDiv' DOM element e.g. via RJS, if you're using rails:

<pre><code>
render :update do |page|
  page<< "$('innerDiv').setStyle({width: '#{width}px', height: '#{height}px'});"
end
</pre></code>

h4. cellDataUrl

This is called whenever the grid needs some new data (as the user scrolls around, or when the grid first loads). 

This should take the following parameters:
* old_x: previous x-coord of the top-left cell in the viewport (won't be sent first time)
* old_y: previous y-coord of the top-left cell in the viewport (won't be sent first time)
* new_x: new x-coord of the top-left cell in the viewport
* new_y: new y-coord of the top-left cell in the viewport
* number_of_cells_x: how many cells across to show
* number_of_cells_y: how many cells down to show

The method should work out which cells you want to add/remove from the viewport, and then repeatedly make calls to removeCell() and insertCell() on your instance of grrid.Grid.  This url is called in exactly the same way in edit mode and view mode.  So your code needs to make sure it's fetching the right data.

h4. synchronizationUrl

This is called periodically by the client, to inform the server of changes to cell contents during edit mode.

The client will send a bunch of parameters in a hash, with the cell coordinates as the key (e.g. "1,4") and the cells' new contents as the values.  You should write code to keep track of this changed data which is waiting to be saved (but may be discarded if the user chooses not to save).

h4. saveUrl

No parameters

When the client calls this url, it is telling the server that it wants to save the current representation of the grid.  Do whatever you need to do to make permanent the server's current representation of the data (which has been kept up to date by all the previous synchronizations).

h4. showUrl

This is simply the url that you want to redirect to once the data has been saved (i.e. to show the grid in view mode).







